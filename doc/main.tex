\documentclass[a4paper,parskip=full]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage{cmbright}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{minted}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{pgfgantt}
\usepackage{tabulary}
\usepackage[page]{appendix}
% http://wiki.luatex.org/index.php/Attributes
% conflicts with \attribute from pgf-umlcd
\let\attribute\relax
\usepackage{pgf-umlcd}
\usepackage{pgf-umlsd}

\setlist{parsep=10pt}

\newcommand{\py}[1]{\mintinline{python}{#1}}
\newcommand{\fixme}[1]{\textbf{FIXME} \emph{#1}}

\hyphenation{Web-Extension}
\hyphenation{Web-Extensions}

\begin{document}

%\title{qutebrowser made extendible \\ FIXME}
%\author{Florian Bruhin \\ \url{florian@qutebrowser.org}}
%\date{\today}
%\maketitle

\begin{titlepage}

\begin{flushleft}

% Upper part of the page
\noindent\begin{minipage}[t]{0.49\textwidth}
	\begin{flushleft}
		\vspace{3pt} %needed else aligned to bottom
		\includegraphics[height=0.12\textheight]{img/hsr.eps}
	\end{flushleft}
\end{minipage}
\hfill
\begin{minipage}[t]{0.49\textwidth}
	\begin{flushright}
		\vspace{0pt} %needed else aligned to bottom
		\includegraphics[height=0.15\textheight]{img/qutebrowser.png}
	\end{flushright}
\end{minipage}
\\[4cm]

{\huge \bfseries qutebrowser made extendible}\\[0.5cm]
%{\large \bfseries Student Research Project (Studienarbeit)}\\[2cm]
{\large \bfseries Term Project (Studienarbeit) \\[0.2cm] Autumn Term 2018/2019}\\[2cm]

Department of Computer Science\\
University of Applied Sciences Rapperswil (HSR)\\
\url{www.hsr.ch}\\[1cm]

% Author and advisor
Author: Florian Bruhin\\[0.3cm]
Advisor: Prof.~Stefan Keller, HSR\\[0.3cm]
External Co-Examiner: Claude Eisenhut, Eisenhut Informatik AG

% Bottom of the page
\vfill
Date: {\today}

\end{flushleft}

\end{titlepage}



\chapter*{Abstract}

\chapter*{Management Summary}


\tableofcontents
\listoffigures
\listoftables


% Aufgabenstellung
\chapter*{Task Definition}

% Einführung
\chapter{Introduction}

\section{Background}

\fixme{main focus: What's qutebrowser about? When/technology should be in the
  second paragraph. Maybe define web browser. Also define Python/PyQt. List
alternatives.}

The qutebrowser project has existed since December 2013. It is a keyboard-focused
web browser with a minimal GUI, based on Python and PyQt5.

An extension API for users to write their own extensions to qutebrowser is a
long-standing feature
request\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/30}},
which has often been requested by its users.

It is difficult to estimate qutebrowser's user count, but it is most likely used by a
couple thousand users, so an extension API is also vital in order to be able to move
less popular features out of the core part of qutebrowser.

\label{backends}
There are two backends (rendering engines) which can be used with qutebrowser:

\begin{itemize}
  \item \emph{QtWebKit} which is based on the
  WebKit\footnote{\url{https://www.webkit.org/}} project
  \item \emph{QtWebEngine} which is based on the
  Chromium\footnote{\url{https://www.chromium.org/}} project, which is also used
  in Google Chrome (used as default).
\end{itemize}

In order to allow using either backend, qutebrowser provides an abstraction
layer over the two libraries, implementing the adapter pattern
\citep[p.~139ff]{gof}. This abstraction layer is referred to as ``tab API'', and
documented in section \ref{tabapi}.

% Problemstellung, Vision
\section{Vision}
\label{vision}

\fixme{further define power users}

Many qutebrowser users are power-users and, as such, have very specific (and
sometimes unique) feature requests and workflows. It should be made possible for
those users to extend qutebrowser with custom extensions in an easy way, in order
to keep qutebrowser's core small.

Since qutebrowser already has a thriving community, this change also intends to
decentralize development efforts, as it enables power-users and
developers to maintain their extensions independently from the core development.

% Ziele und Unterziele
\section{Goals}
\label{goals}

Initially, qutebrowser was developed without knowledge of proper software
engineering practices, which resulted in some maintainability issues. While many
of those issues have since been resolved, some still remain. Those
refactorings affect the API exposed to extensions, and therefore should be taken
care of before attempting to design a extension API.

The full list of relevant refactorings is tracked as a Kanban
board\footnote{\url{https://github.com/qutebrowser/qutebrowser/projects/3}} in
qutebrowser's GitHub repository. The biggest planned changes are the following:

\begin{itemize}
  \item \url{https://github.com/qutebrowser/qutebrowser/issues/1456}: \\ Parts of qutebrowser already use Python type
    annotations\footnote{\url{https://www.python.org/dev/peps/pep-0484/}}, but
    only if contributors decide to use them. In addition to that, no type
    checker such as mypy\footnote{\url{http://mypy-lang.org/}} is currently run
    as part of qutebrowser's continuous integration (CI) pipeline, thus allowing
    regressions to occur. As part of this project, a type checker should be
    introduced into the CI infrastructure, and any code exposed via the extension
    API should be annotated with proper type annotations.
  \item \url{https://github.com/qutebrowser/qutebrowser/issues/345}: \\
    To generate HTML documentation, qutebrowser currently uses
    asciidoc\footnote{\url{http://asciidoc.org/}} which is unsuitable for API
    documentation and ceased maintenance. An external contributor (see page
    \pageref{fiete}) is currently working on migrating to the
    Sphinx\footnote{\url{http://www.sphinx-doc.org/}} toolchain, and should be
    supported with his work throughout the SA.
  \item \url{https://github.com/qutebrowser/qutebrowser/issues/640}: \\
    Global objects are registered in a object registry based on a name as
    string (``stringly-typed''\footnote{\url{http://wiki.c2.com/?StringlyTyped}}).
    This historically caused various object-lifetime related issues, and also
breaks tooling such as the mypy type checker. All code using the object registry
should be refactored to use better alternatives such as constructor arguments
(dependency injection).
\end{itemize}

% Rahmenbedingungen, Umfeld, Definitionen, Abgrenzungen
\section{Context}
\label{context}

The software and version constraints are mostly given by the existing project:

\begin{itemize}
  \item Python\footnote{\url{https://www.python.org/}} 3 (3.5 or newer)
  \item Qt\footnote{\url{https://www.qt.io/}} 5 (5.7 or newer), used via PyQt5\footnote{\url{https://www.riverbankcomputing.com/software/pyqt/intro}}
  \item pytest\footnote{\url{https://pytest.org/}} as test framework
  \item Various code quality tools: pylint\footnote{\url{https://pylint.org/}},
    flake8\footnote{\url{http://flake8.pycqa.org/}} and others.
\end{itemize}

As qutebrowser is a pre-existing project with a vibrant community, external
contributions are expected to continue (despite an
announcement\footnote{\url{https://lists.schokokeks.org/pipermail/qutebrowser-announce/2018-October/000053.html}, accessed 2018-11-12}
asking people to refrain from making larger contributions). This can be challenging,
as it results in refactorings being carried out against a moving target. Because
of the nature of open-source contributions,
% http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/
% https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/
it is hard to foresee or control which areas external contributors are changing.
At the beginning of the SA, some time was allocated for merging external
contributions (pull requests) which were already open. For the rest of the SA,
such contributions will be dealt with on a best effort basis, with the main
focus being this documentation and the work required for the extension API.

% Vorgehen, Aufbau der Arbeit
\section{Methods and Structure}


% Projektmanagement (Planung, Soll)
\chapter{Project Management}

% Prototypen, Releases, Meilensteine
\section{Prototypes, Releases, Milestones}
Since this project is done without any external industry partner, there is no
immediate need for fixed releases or prototypes during the SA.

However, the following releases are planned:

\begin{itemize}
  \item A v1.5.0 feature release as soon as PyQt 5.11.3 is released upstream
    \begin{itemize}
      \item v1.5.0 was released in week 3
    \end{itemize}
  \item Patch releases for v1.5.x as needed in case of regressions or serious
    enough bugs:
    \begin{itemize}
      \item v1.5.1 was released in week 4
      \item v1.5.2 in week 6
      \item v1.5.3 in week \fixme{}
    \end{itemize}
  \item v1.6.0 after the work on refactoring qutebrowser's core into extensions
    is completed, in order to get the changes out to users as soon as possible.
  \item v1.6.x patch releases as needed (probably after the SA is finished)
  \item In the future, after the extension API is open for third-party
    extensions, a v2.0.0 release with some other big changes (like dropping support
    for the older QtWebKit backend, as it's rarely updated upstream, even for
    security issues).
\end{itemize}

At the end of week 11, an API review milestone is planned, where the extension
API design gets reviewed by employees of the IFS (Institute for Software) at the
HSR.

% Team, Rollen und Verantwortlichkeiten
\section{Team and Roles}
\emph{Florian Bruhin} is both the primary maintainer of qutebrowser and the
sole author of this student research project. He has been working on qutebrowser since
December 2013 and started studying Computer Science at HSR in 2016.

\emph{Joël Schwab} intended to co-author this research project, but
unfortunately didn't pass some exams, which were a precondition to be allowed to
do the SA project this semester.

Professor \emph{Stefan Keller}, institute partner at the Institute for Software
(IFS) at HSR is the advisor for this project.

The qutebrowser community is not directly involved in this research project, but
is the primary audience of the resulting work. It has also contributed many
ideas and use cases for future
extensions\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/30}}.
There is no external industry partner.

\label{fiete}
\emph{Fritz Reichwald} (fiete201\footnote{\url{https://github.com/fiete201}})
is a long-time qutebrowser user who is working on migrating qutebrowser's
documentation system from asciidoc\footnote{\url{http://asciidoc.org/}} (which
is deprecated) to the Sphinx\footnote{\url{http://www.sphinx-doc.org/}}
documentation generator. This change was
planned\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/345}}
since December 2014, so his help with tackling this is very much appreciated.
This project will benefit from his work, as Sphinx, unlike asciidoc, is a
very good fit for documenting APIs. His work is clearly marked as such in this
documentation.

% Prozessmodel
\section{Process Model}
Because of previous experience as part of HSR's ``Engineering Project'', the
``Scrum+'' process model will be used, i.e., an agile Scrum process with an
additional ``End of Elaboration'' milestone.

At the beginning of the SA, there was a phase with the goal of merging existing
third-party contributions (pull requests) into qutebrowser, so that the changes
required for extensions does not conflict with existing work. Thus, an additional
\emph{preparation} phase has been introduced, resulting in the following phases:

Inception, Preparation, Elaboration, Construction, Transition

% Aufwandschätzung, Zeitplan, Projektplan
\section{Project Schedule}
\label{schedule}

8 ECTS credits are awarded for the SA-course. Since one ECTS point is equivalent
to a workload of 25--30 hours \citep{ects} and this SA is written by a single
author, this amounts to 200--240 hours of work. The semester consists of 14
weeks, thus, an average workload of 14--17 hours per week is expected. This time
is allotted as shown in figure \ref{img:schedule}.

\begin{figure}[h!]
  \begin{ganttchart}[
        title height = 1,
        y unit title=.5cm,
        y unit chart=.5cm,
        bar/.append style={fill=green!20},
        vgrid={
          *1{blue!60},
          *4{gray, dashed},
          *1{blue!60},
          *2{gray, dashed},
          *1{blue!60},
          *2{gray, dashed},
          *1{gray, dashed}
        }]{1}{14}
    \gantttitle{\hspace{-6.5em}\footnotesize{Calendar week}}{0}{0}
    \gantttitlelist{38,...,51}{1} \\
    \gantttitle{\hspace{-6.5em}\footnotesize{Semester week}}{0}{0}
    \gantttitlelist{1,...,14}{1} \\

    \ganttgroup{Inception}{1}{1} \\
    \ganttmilestone{M0: Kickoff}{1} \\

    \ganttgroup{Preparation}{2}{6} \\
    \ganttbar{Qt 5.12 release}{2}{2} \\
    \ganttbar{Merge contributions}{3}{5} \\
    \ganttbar{Buffer}{6}{6} \\

    \ganttmilestone{M1: Most contributions addressed}{6} \\

    \ganttgroup{Elaboration}{7}{9} \\
    \ganttbar{Existing approaches}{7}{7} \\
    \ganttbar{Project documentation}{8}{8} \\
    \ganttbar{API design}{9}{9} \\

    \ganttgroup{Construction}{10}{13} \\
    \ganttbar{Introducing MyPy}{10}{10} \\
    \ganttbar{Adding extension API}{11}{12} \\
    \ganttmilestone{M2: API review}{11} \\
    \ganttbar{Refactoring core into extensions}{11}{12} \\
    \ganttmilestone{M3: v1.6.0 release}{12} \\
    \ganttbar{Buffer}{13}{13} \\

    \ganttgroup{Transition}{14}{14} \\
    \ganttbar{Finishing documentation}{14}{14} \\

    \ganttmilestone{M4: Project end}{14}
  \end{ganttchart}
  \caption{Project schedule}
  \label{img:schedule}
\end{figure}

Due to the relatively long \emph{preparation} phase at the beginning of the
project, the \emph{construction} phase gets unusually short. This is
unfortunate but unavoidable -- it's important to integrate existing
contributions before starting to refactor the existing code, at least for
third-party changes which would lead to conflicts with refactoring changes.

% Risiken
\section{Risks}
The following risks have been identified in this project:

\fixme{Should have a time, if possible -- see ÖV-Güteklassen 2018?}

\begin{table}[h!]
  \begin{tabulary}{\linewidth}{LLL}
    \toprule
    Risk & Mitigation & Probability (1-5) \\
    \midrule
    Too many external contributions & Asking contributors to hold back further contributions; ignoring existing contributions & 5 \\
    \hline
    Little time in construction phase & Work on extension API is very
    scalable, buffers in schedule & 4 \\
    \hline
    Sickness of author & Work on extension API is very scalable & 3 \\
    \hline
    Future breaking API changes needed & API is not exposed for third-party
    contributions yet & 3 \\
    \hline
    Migrating documentation toolchain to Sphinx (done by external contributor)
    is not done in time & Initial extension API documentation can be separate from
    qutebrowser documentation & 3 \\
    \bottomrule
  \end{tabulary}
\end{table}

As explained in section \ref{context}, it's expected that third-party
contributors continue to submit changes (in the form of pull requests) while
this SA is ongoing. An
announcement\footnote{\url{https://lists.schokokeks.org/pipermail/qutebrowser-announce/2018-October/000053.html},
  accessed 2018-11-12} was sent out, asking contributors to cut back external
contributions. However, a similar announcement was sent out during past exam
seasons, with mixed results -- many contributors continue to submit changes
regardless. Initially, there's a phase focused on merging existing
contributions (see the project schedule in section \ref{schedule}). Afterwards,
contributions are dealt with on a best effort basis, being ignored if they
are non-trivial.

There's little time in the construction phase compared to other projects.
Additionally, this SA is written by a single author. Thus, sickness or other
obstructions have a bigger than usual impact. This is counteracted by trying to
keep the scope of the SA clear, but flexible. Additionally, buffer time is
added after the preparation and construction phases in the project schedule
(section \ref{schedule}).

If some preparatory work isn't finished fully, it's possible that upcoming
changes cause incompatible changes in the extension API. However, this SA
is focused on moving core code into extensions, rather than providing an
extension API for third-party extensions. Therefore, it's still possible to make
those changes after the SA is finished, without breaking third-party code.


\chapter{Requirements Specification}

% Use Cases (Success Scenario / Success Diagram)
\section{Use Cases}

This project extends an existing codebase with an extension API rather
than starting a new project from scratch. By its nature, it's difficult to
predict how an extension API will be used in the future. Because of that, an
use-case diagram would not adequately describe the motivation for the extension
API.

Various ideas for future third-party extensions have been voiced by the
qutebrowser community; they are collected in a GitHub
issue\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/30},
  accessed 2018-11-08}. However, the main aim of this project (and thus the main
focus for the extension API) is reducing the complexity of qutebrowser's core.

% Weitere Funktionen, die nicht erfasst wurden
%\section{Further Functionality}

% Nicht-funktionale Anforderungen (Rahmbenbedingungen, evtl. Verweis auf 1.3)
\section{Non-functional Requirements}
The following non-functional requirements are relevant for qutebrowser's
extension API:

\begin{description}
  \item[Security] The security model used for qutebrowser extensions assumes
    that extensions are trusted, i.e., may run arbitrary code. See
    section \ref{security} for a more detailed explanation.
  \item[Simplicity] It should be trivial for a user to extend her qutebrowser
    setup with a custom extension. Thus, getting started with writing a
    third-party extension should be as straightforward as possible, without
    requiring packing multiple files into a custom format. Also see section
    \ref{anatomy} for an explanation on how this topic is handled for
    WebExtensions, and how qutebrowser's API differs from that.
  \item[Learnability] When the extension API is opened for third-party
    contributions, it should be easy to get accustomed to it. Therefore, the API
    should be intuitive for Python programmers, and well documented.
  \item[Compability] The qutebrowser project runs on a variety of different
    software versions -- various operating systems (Linux, macOS, Windows,
    and more) are supported, including different Qt and Python versions. The
    extension API should abstract over those differences, so an extension
    written for qutebrowser (or core code moved into such an extension) runs in
    all situations qutebrowser itself can run.
  \item[Performance] \fixme{Add something about performance vs. small core}
\end{description}

% % Detailspezifikation
% \section{Detailed Specification}
% \fixme{???}
% 
% % Analyse (Business Model)
% \chapter{Analysis}
% 
% % Domain Modell, Klassendiagramme (konzeptionell)
% \section{Domain Model}
% 
% % Objektkatalog (Beschreibung der Konzepte, bzw. Entitätsmengen)
% \section{Objects}

% "Stand der Technik" (Was gibt es schon?)
\chapter{Existing APIs}
\label{unsuitable}

\fixme{}: Introductory text here?

\section{Firefox XUL extension API}

Older versions of the Firefox web browser used to have a very powerful extension
API, based on its XUL (XML User Interface Language) technology. However, this
approach presented various challenges and was thus recently abandoned, while
adopting the WebExtensions standard.

The apparent philosophy behind ``legacy'' Firefox addons was to allow maximum
customizability from extensions -- however, this came with various drawbacks
which ultimately led to Mozilla abandoning that approach.

The motivations to deprecate and subsequently remove the legacy addon API listed
in Mozilla's blog post \citep{mozilla-webext} were as follows:

\begin{itemize}
  \item Chrome and Opera (and nowadays also Microsoft Edge) already supported
    the WebExtension API, so a switch to the WebExtension API would drastically
    reduce the effort required for developers when implementing extensions with
    cross-browser compatibility: \emph{``We would like add-on development to be more
    like Web development: the same code should run in multiple browsers according to
    behavior set by standards, with comprehensive documentation available from
    multiple vendors.''}
  \item Firefox' Electrolysis (e10s)
    project\footnote{\url{https://wiki.mozilla.org/Electrolysis}} was a big
    change in its codebase, with the goal of separating tabs into separate
    processes, for security and performance reasons. Many legacy addons were not
    compatible with the changes necessary for Electrolysis. This forced either
    the add-on developer to make (sometimes intricate) changes to their code; or
    the user's Firefox instance to run in a special fallback mode: \emph{``Add-ons
    that haven't been upgraded to work with Electrolysis will run in a special
    compatibility environment that resembles single-process Firefox as much as
    possible. [...] However, [the fallback is] much slower than the equivalent DOM
    operations in single-process Firefox, and can affect the user experience
    negatively. Also, some accesses aren't supported by the compatibility layer and
    will throw exceptions.''}
  \item Since Firefox is a quite popular product, malicious Firefox addons
    started to become an attractive attack vector for bad actors. With legacy
    addons, addon code is able to run arbitrary code and freely modify Firefox
    internals on the user's machine, which turns untrusted addons into a
    security liability \citep{mozilla-signing}.
  \item Legacy addons hindered Firefox development in general, since its
    powerful addon API introduced a tight coupling between Firefox' internal
    code, and the code in third-party addons: \emph{``A permissive add-on model
    means that we have limited flexibility in changing the foundations of Firefox.
    [...] Without a fundamental shift to the way Firefox add-ons work, we will
    be unable to use new technologies like Electrolysis, Servo\footnote{An
      experimental new rendering engine by Mozilla, implemented in the Rust
      programming language. Parts of Servo (such as its CSS renderer) have since
    been merged into Firefox.} or browser.html\footnote{A Mozilla research
    project which implements a browser completely in HTML, now retired.}
    as part of Firefox. The tight coupling between the browser and its add-ons
    also creates shorter-term problems for Firefox development. It's not uncommon
    for Firefox development to be delayed because of broken add-ons.''}
\end{itemize}

While qutebrowser should learn from the mistakes made in Firefox' legacy API,
a more thorough analysis of the XUL API design proved to be difficult. Archived
API documentation is still
available\footnote{\url{https://developer.mozilla.org/en-US/docs/Archive/Add-ons}},
but bad documentation was one of the criticisms of XUL addons
\citep{mozilla-webext}. Since the API is not in active use anymore, and ties
into Firefox' core code deeply, no further analysis was performed.

The key takeaway for qutebrowser is that it should have a minimal and clearly
outlined extension API, rather than naively exposing its internal Python code to
extensions.

\section{WebExtensions API}
\label{webextensions}

Currently, there are ongoing efforts towards an API for browser
extensions called \emph{WebExtensions}, which is shared between different
browsers. WebExtensions are supported by Chrome, Opera, Firefox and Edge.
Efforts are currently underway to standardize the API as a W3C specification
\citep{w3c-webext}. At the moment, each browser has a slightly different set of
supported APIs, with some divergence in naming. As an example, the
\verb|chrome.| module is used in Chromium for browser-specific features, while
Firefox uses \verb|browser.|.

If qutebrowser supported the WebExtension API, it would follow a common
standard, and enable running thousands of existing Chromium extensions with
little to no adjustment to their code.

Unfortunately, WebExtensions are unsuitable for qutebrowser, for various
reasons:

\begin{itemize}
  \item Full WebExtension support would likely require some degree of support by
    the underlying rendering engine. While there is an open
    suggestion\footnote{\url{https://bugreports.qt.io/browse/QTBUG-61676}} in
    Qt's bug tracker, no work on that has been started so far.
  \item Implementing WebExtension support in Python only (without any support
    from the underlying backend) is hard, if possible at all. Neither
    backend allows deep access to its JavaScript engine
    (V8\footnote{\url{https://v8.dev/}} for QtWebEngine, JavaScriptCore for
    QtWebKit), which means extension code would have to run in a separate
    JavaScript interpreter (such as Qt's
    \verb|QJSEngine|\footnote{\url{http://doc.qt.io/qt-5/qjsengine.html}} class).
    However, extensions should have access to web contents. Thus, a secure
    communication channel is needed between the backend's JavaScript interpreter
    (used for the page), and the separate interpreter used for extensions. In
    addition, it should only be possible for extensions to access page content,
    not the other way around, as that would be a security issue. All in all,
    this approach is prohibitively complex, and thus out of scope for this SA.
  \item Most qutebrowser users and contributors are accustomed to writing Python
    code (since qutebrowser itself is written in Python). While a WebExtension
    API (in JavaScript) would allow using thousands of existing Chrome extensions, a
    Python API will make it easier for users to write custom additions to
    qutebrowser to suit their needs.
  \item The security model of WebExtensions is fundamentally different from
    what's intended for qutebrowser extensions -- WebExtension code is sandboxed,
    and unable to run arbitrary code on the user's machine. This can be worked
around by using WebExtension's ``native
    messaging''\footnote{\url{https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Native_messaging}}
    capability with a separate application running in the background, but doing
    so is cumbersome. See \ref{security} for an explanation on the security
    model of qutebrowser extensions.
  \item The WebExtension API was not designed with the Qt APIs in mind, yet
    qutebrowser is bound to using those. In some cases it might be possible to
    write an adapter to bring the two approaches together; but if they are
    fundamentally different, doing so might prove difficult. With a custom API,
    there's more control over the tradeoff between an API which closely follows
    Qt's (and thus reduces friction and complexity), or an API which prioritizes
    other considerations (see \ref{criteria}).
\end{itemize}

While it is not possible for qutebrowser to implement support for WebExtensions,
they are still useful as a source for API design inspiration. However, it
should be noted that the WebExtension API is closely tied to the JavaScript
language, so architecture decisions taken there will not necessarily be
applicable to qutebrowser's Python extension API.

\subsection{Anatomy of a WebExtension}
\label{anatomy}

As explained in Mozilla's
documentation\footnote{\url{https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Anatomy_of_a_WebExtension},
  accessed 2018-11-08},
a WebExtension consists of various files:

\begin{itemize}
  \item A \verb|manifest.json| manifest file, which lists meta information about
    an extension, such as its name, its author, or the permissions it requests.
  \item Background scripts, which are used to implement long-running operations.
    An extension's background scripts are loaded for the entire lifetime of an
    extension, i.e., until it is disabled or uninstalled.
  \item Content scripts, which are injected into loaded web pages, and can
    interact with their content (access and manipulate the DOM). They also have
    some additional permissions, which scripts supplied by the page do not have,
    such as messaging with an extension's background scripts.
  \item HTML pages for user interfaces such as an extension's option page or sidebar.
  \item Other resources such as icons.
\end{itemize}

Those files are then packaged into a specially named ZIP file (XPI in case of
Firefox; CRX for Chromium) and distributed via an extension store (a special
website run by Mozilla/Google).

For qutebrowser extensions, a simpler approach will be taken: Extensions can
consist of a single standalone \verb|.py| file which implements the necessary
functionality. This mechanism is inspired by the plugin handling of the pytest
project\footnote{\url{https://docs.pytest.org/en/latest/writing_plugins.html},
  accessed 2018-11-08}. In the future, this makes it trivial for users to add
their own extensions to qutebrowser. That solution is also very straightforward and
appropriate for the initial goal of refactoring qutebrowser's core code into
extensions.

Due to extensions being written in Python, the above separation between content
and background scripts also does not fully apply to qutebrowser's API. The Python
extensions can be seen as a background script. It initially won't be able to
interact with web pages, as this functionality isn't needed before third-party
extensions are enabled. See the API analysis below for further details.

\subsection{Analysis of the WebExtension API}

The WebExtensions API is separated into various modules, each of which is
briefly analyzed in the context of qutebrowser in this section, sorted
alphabetically. The indented descriptions are copied verbatim from Mozilla's API
documentation\footnote{\url{https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API},
  \\ accessed 2018-11-02}.

\subsubsection{alarms}
\begin{quote}
Schedule code to run at a specific time in the future.
\end{quote}

Since qutebrowser extensions will have access to the Qt GUI library, no
equivalent to this module is needed. Qt provides the
\verb|QTimer|\footnote{\url{http://doc.qt.io/qt-5/qtimer.html}} class, which can
be used for equivalent functionality.

\subsubsection{bookmarks}
\begin{quote}
The WebExtensions bookmarks API lets an extension interact with and manipulate the browser's bookmarking system. You can use it to bookmark pages, retrieve existing bookmarks, and edit, remove, and organize bookmarks.
\end{quote}

Bookmarks in qutebrowser are currently much simpler than they are in Firefox or
Chrome; i.e. they are not organized in a tree-like structure, and features like
tags are missing. Therefore, the bookmarks WebExtension API does not fit well
with qutebrowser bookmarks.

There's an ongoing
contribution\footnote{\url{https://github.com/qutebrowser/qutebrowser/pull/3855}}
to add such features, and it would make little sense to add an extension API before
that contribution is merged. Since access to bookmarks isn't vital for an extension
API, it is currently out of scope.

\subsubsection{browserAction, menus, pageAction, sidebarAction}
\begin{quote}
browserAction: Adds a button to the browser's toolbar.
\end{quote}
\begin{quote}
menus: Add items to the browser's menu system.
\end{quote}
\begin{quote}
pageAction: A page action is a clickable icon inside the browser's address bar.
\end{quote}
\begin{quote}
sidebarAction: Gets and sets properties of an extension's sidebar.
\end{quote}

Those modules allow extensions to add their own user interface elements to the
browser, as shown in figure \ref{img:browser-action}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\linewidth]{img/browser-action.png}
  \caption{A button added via the \texttt{browserAction} WebExtension API}
  \label{img:browser-action}
\end{figure}

It should be possible for custom qutebrowser extensions to add their own user
interface elements. However, this functionality is unlikely to be needed
when moving core functionality into extensions (which is the main focus of this
SA). Therefore, this API is currently out of scope.

\subsubsection{browserSettings}
\begin{quote}
Enables an extension to modify certain global browser settings.
\end{quote}

Extensions for qutebrowser should be able to modify its settings, and also
define their own options.

\subsubsection{browsingData}
\begin{quote}
Enables extensions to clear the data that is accumulated while the user is
browsing.
\end{quote}

No such functionality is currently implemented in qutebrowser, so this API is
out of scope.

\subsubsection{clipboard}
\begin{quote}
The clipboard API enables an extension to copy items to the system clipboard.
\end{quote}

Since qutebrowser extensions will have access to the Qt GUI library, no
equivalent to this module is needed. Qt provides the
\verb|QClipboard|\footnote{\url{http://doc.qt.io/qt-5/qclipboard.html}} class, which can
be used for equivalent functionality.

\subsubsection{commands}
\begin{quote}
Listen for the user executing commands that you have registered using the commands manifest.json key.
\end{quote}

This API is used to register custom keyboard shortcuts in WebExtensions. A
similar concept also exists in qutebrowser, where commands can either be bound
to keys (using the configuration), or executed in the commandline via \verb|:command|.

This API is important, since many core parts register commands in qutebrowser
(like \verb|:adblock-update| for the ad blocker). Thus, Extensions should be
able to register Python functions as commands.

\subsubsection{contentScripts}
\begin{quote}
With the contentScripts API, an extension can register and unregister scripts at runtime.
\end{quote}

Injecting custom JavaScript code into websites will be an useful feature for
custom extensions at a later stage, but isn't needed to move code out of
qutebrowser's core, as it's expected for internal JavaScript code to stay in the
core part. Thus, this module is currently out of scope.

Running JavaScript one-off snippets (triggered manually, rather than
automatically on page load) is already implemented in the tab API, and should be
trivial to expose to extensions.

\subsubsection{contextualIdentities, i18n, identity, idle, notifications, pkcs11, topSites}
\begin{quote}
contextualidentities: Work with contextual identities: list, create, remove, and update contextual identities.
\end{quote}
\begin{quote}
i18n: Functions to internationalize your extension. You can use these APIs to get localized strings from locale files packaged with your extension, find out the browser's current language, and find out the value of its Accept-Language header.
\end{quote}
\begin{quote}
identity: Use the identity API to get an OAuth2 authorization code or access token, which an extension can then use to access user data from a service which supports OAuth2 access (such as a Google or a Facebook account).
\end{quote}
\begin{quote}
idle: Find out when the user's system is idle, locked, or active.
\end{quote}
\begin{quote}
notifications: Display notifications to the user, using the underlying operating system's notification mechanism.
\end{quote}
\begin{quote}
pkcs11: The pkcs11 API enables an extension to enumerate PKCS\#11 security modules, and to make them accessible to the browser as sources of keys and certificates.
\end{quote}
\begin{quote}
topSites: Use the topSites API to get an array containing pages that the user has visited often and frequently.
\end{quote}

No such functionality is currently implemented in qutebrowser, so those modules
are out of scope.

\subsubsection{cookies}
\begin{quote}
Enables extensions to get and set cookies, and be notified when they change.
\end{quote}

Cookie access isn't fully exposed by the QtWebEngine
library\footnote{\url{http://doc.qt.io/qt-5/qwebenginecookiestore.html}}, so
it's currently not possible to implement this module.

\subsubsection{devtools}
\begin{quote}
The devtools.inspectedWindow API lets a devtools extension interact with the window that the developer tools are attached to.
\end{quote}

\begin{quote}
The devtools.network API lets a devtools extension get information about network requests associated with the window that the devtools are attached to (the inspected window).
\end{quote}

\begin{quote}
The devtools.panels API lets a devtools extension define its user interface inside the devtools window.
\end{quote}

Access to developer tools isn't exposed by the QtWebEngine library, so it's
currently not possible to implement this module.

\subsubsection{dns}
\begin{quote}
Enables an extension to resolve domain names.
\end{quote}

Since qutebrowser extensions will have access to the Qt GUI library, no
equivalent to this module is needed. Qt provides the
\verb|QDnsLookup|\footnote{\url{http://doc.qt.io/qt-5/qdnslookup.html}} class, which can
be used for equivalent functionality.

\subsubsection{downloads}
\begin{quote}
Enables extensions to interact with the browser's download manager. You can use this API module to download files, cancel, pause, resume downloads, and show downloaded files in the file manager.
\end{quote}

This module is needed for various core parts (such as the ad blocker, to
download filter lists).

\subsubsection{events, extensions, extensionTypes, permissions, runtime, types}
\begin{quote}
events: Common types used by APIs that dispatch events.
\end{quote}
\begin{quote}
extensions: Utilities related to your extension. Get URLs to resources packages with your extension, get the Window object for your extension's pages, get the values for various settings. Note that the messaging APIs in this module are deprecated in favor of the equivalent APIs in the runtime module.
\end{quote}
\begin{quote}
extensionTypes: Some common types used in other WebExtension APIs.
\end{quote}
\begin{quote}
permissions: Extensions need permissions to access more powerful WebExtension APIs. They can ask for permissions at install time, by including the permissions they need in the permissions manifest.json key. The main advantages of asking for permissions at install time are:
\end{quote}
\begin{quote}
runtime: This module provides information about your extension and the environment it's running in.
\end{quote}
\begin{quote}
types: Defines the BrowserSetting type, which is used to represent a browser setting.
\end{quote}

Those APIs are specific to the WebExtensions API, and thus irrelevant for
qutebrowser.

\subsubsection{find}
\begin{quote}
Finds text in a web page, and highlights matches.
\end{quote}

This functionality is already available as part of qutebrowser's tab API (see
section \ref{tabapi}), and should be trivial to expose to extensions.

\subsubsection{history}
\begin{quote}
Use the history API to interact with the browser history.
\end{quote}

Accessing and manipulating the history might be an useful feature for future
user-contributed extensions, but is likely not needed for moving code out of
qutebrowser's core. Thus, the history module is currently out of scope.

\subsubsection{management}
\begin{quote}
Get information about installed add-ons.
\end{quote}

Extensions are currently not expected to interact with each other (even less so
when moving code out of the core), so this module is not needed.

\subsubsection{omnibox}
\begin{quote}
Enables extensions to implement customised behavior when the user types into the
browser's address bar.
\end{quote}

When adding custom commands, extensions also should be able to specify a
completion function, so users can use qutebrowser's autocompletion when typing
the extension's commands.

\subsubsection{privacy}
\begin{quote}
Access and modify various privacy-related browser settings.
\end{quote}

In qutebrowser, those settings (like
\verb|privacy.network.webRTCIPHandlingPolicy|) are exposed as normal qutebrowser
setttings (like \verb|content.webrtc_ip_handling_policy|), so there's no need
for a similar module in the extension API.

\subsubsection{proxy}
\begin{quote}
Use the proxy API to proxy web requests. There are two different ways you can do this:
\end{quote}

No low-level networking access is possible via the QtWebEngine API, so this
module will not be implemented.

\subsubsection{search}
\begin{quote}
Retrieves search engines and executes a search with a specific search engine.
\end{quote}

Search engines are part of the main configuration in qutebrowser, so an
extension can trivially retrieve a search engine from there and execute a query
without the need for a dedicated API.

\subsubsection{sessions}
\begin{quote}
Use the sessions API to list, and restore, tabs and windows that have been closed while the browser has been running.
\end{quote}

While qutebrowser does have a session feature, access to it is not vital for an
extension API, so this is currently out of scope.

\subsubsection{storage}
\begin{quote}
Enables extensions to store and retrieve data, and listen for changes to stored items.
\end{quote}

Having a simple way to persist data for extensions will be an useful feature for
third-party extensions, but is currently not needed when moving code out of the core.

\subsubsection{tabs, windows}
\begin{quote}
tabs: Interact with the browser's tab system.
\end{quote}
\begin{quote}
windows: Interact with browser windows. You can use this API to get information about open windows and to open, modify, and close windows. You can also listen for window open, close, and activate events.
\end{quote}

Various functionality already exists in qutebrowser as part of the ``tab API''
(documented in section \ref{tabapi}), which should be trivial to expose to the
extension API. Furthermore, the \verb|tabs| and \verb|windows| modules contains
various functionality to retrieve tabs, which should be added to qutebrowser's
extension API.

\subsubsection{theme}
\begin{quote}
Enables browser extensions to update the browser theme.
\end{quote}

No dedicated theme feature exists in qutebrowser - instead, qutebrowser's user
interface can be customized using its configuration.

\subsubsection{webNavigation}
\begin{quote}
Add event listeners for the various stages of a navigation. A navigation consists of a frame in the browser transitioning from one URL to another, usually (but not always) in response to a user action like clicking a link or entering a URL in the location bar.
\end{quote}

This exposes various events such as \verb|webNavigation.onCompleted|. Those will
be exposed as part of the tab API in qutebrowser, as Qt signals such as \verb|load_finished|.

\subsubsection{webRequest}
\begin{quote}
Add event listeners for the various stages of making an HTTP request. The event listener receives detailed information about the request, and can modify or cancel the request.
\end{quote}

The \verb|webRequest| module allows extensions to intercept and change HTTP
network requests. Many of the fine-grained modifications exposed by
WebExtensions (such as \verb|onResponseStarted| to modify the network response)
are not available in the QtWebEngine API, so exposing them in qutebrowser's API
won't be possible. However, it's possible to intercept and block network
requests, and such functionality is critical to move components like the ad
blocker out from the core.

\section{qutebrowser tab API}
\label{tabapi}

As explained in section \ref{backends}, qutebrowser supports two rendering
engines (QtWebKit and QtWebEngine) and provides an abstraction layer (``tab
API'') over those backends, representing a single tab in the browser.

The tab API has been designed with clean API design in mind, as an extension API
already was on the horizon when implementing it. Its goal is that the rest of
qutebrowser's code never has to access backend-specific functionality (like the
\verb|QWebEngineView|\footnote{\url{https://doc.qt.io/qt-5/qwebengineview.html}}
class) directly, and uses the abstraction layer instead.

The tab API is grouped into various classes:

\begin{figure}[h]
\begin{tikzpicture}
  \begin{class}[text width=2cm]{Tab}{6,2}
  \end{class}

  \begin{class}[text width=2cm]{Audio}{0,0}
  \end{class}
  \association{Tab}{}{}{Audio}{}{}

  \begin{class}[text width=2cm]{Elements}{1.5,4.5}
  \end{class}
  \association{Tab}{}{}{Elements}{}{}

  \begin{class}[text width=2cm]{History}{3,0}
  \end{class}
  \association{Tab}{}{}{History}{}{}

  \begin{class}[text width=2cm]{Scroller}{4.5,4.5}
  \end{class}
  \association{Tab}{}{}{Scroller}{}{}

  \begin{class}[text width=2cm]{Caret}{6,0}
  \end{class}
  \association{Tab}{}{}{Caret}{}{}

  \begin{class}[text width=2cm]{Zoom}{7.5,4.5}
  \end{class}
  \association{Tab}{}{}{Zoom}{}{}

  \begin{class}[text width=2cm]{Search}{9,0}
  \end{class}
  \association{Tab}{}{}{Search}{}{}

  \begin{class}[text width=2cm]{Printing}{10.5,4.5}
  \end{class}
  \association{Tab}{}{}{Printing}{}{}

  \begin{class}[text width=2cm]{Action}{12,0}
  \end{class}
  \association{Tab}{}{}{Action}{}{}

  \begin{class}[text width=2cm]{TabData}{10,2}
  \end{class}
  \association{Tab}{}{}{TabData}{}{}
\end{tikzpicture}
\caption{Class diagram for tab API}
\end{figure}

With the exception of \verb|TabData| which is backend-agnostic, all those
objects exist as an abstract base class and as concrete implementations for
QtWebKit/QtWebEngine each:

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}
  \begin{class}[text width=3cm]{AbstractTab}{2,0}
  \end{class}

  \begin{class}[text width=3cm]{WebKitTab}{0,-2}
    \inherit{AbstractTab}
  \end{class}

  \begin{class}[text width=3cm]{WebEngineTab}{4,-2}
    \inherit{AbstractTab}
  \end{class}
\end{tikzpicture}
\end{center}
\caption{Inheritance tree of tab API classes}
\end{figure}

The API exposed by those objects is quite long, so it's not included in full in
this documentation.\footnote{The full API is available at
  \url{https://github.com/qutebrowser/qutebrowser/blob/v1.5.2/qutebrowser/browser/browsertab.py},
accessed 2018-11-09.} As an example, the public API exposed in the main
\verb|Tab| object is listed in figure \ref{tabapi}.

Some parts of the API (like the \verb|networkaccessmanager()| or
\verb|user_agent()| methods) are only exposed because there was a need in
qutebrowser's core to do so, but shouldn't be exposed via the extension API.
However, for the most part, the tab API can be exposed unmodified to extensions
and already allow for a wide range of interactions with tabs.

\begin{figure}
\begin{minted}{python}
window_close_requested = pyqtSignal()
link_hovered = pyqtSignal(str)
load_started = pyqtSignal()
load_progress = pyqtSignal(int)
load_finished = pyqtSignal(bool)
icon_changed = pyqtSignal(QIcon)
title_changed = pyqtSignal(str)
load_status_changed = pyqtSignal(str)
new_tab_requested = pyqtSignal(QUrl)
url_changed = pyqtSignal(QUrl)
shutting_down = pyqtSignal()
contents_size_changed = pyqtSignal(QSizeF)
add_history_item = pyqtSignal(QUrl, QUrl, str)
fullscreen_requested = pyqtSignal(bool)
renderer_process_terminated = pyqtSignal(TerminationStatus, int)
predicted_navigation = pyqtSignal(QUrl)

def event_target() -> QWidget
def progress() -> int
def load_status() -> LoadStatus
def title() -> str
def icon() -> QIcon
def networkaccessmanager() -> QNetworkAccessManager
def user_agent() -> str

def send_event(evt: QEvent)
def handle_auto_insert_mode(ok: bool)
def url(requested: bool) -> QUrl
def openurl(url: QUrl, predict: bool)
def reload(force: bool)
def stop()
def clear_ssl_errors()
def key_press(key: Qt.Key, modifier: Qt.KeyboardModifier)
def dump_async(callback: Callable, plain: bool)
def run_js_async(code: str, callback: Callable, world: JsWorld)
def shutdown()
def set_html(html: str, base_url: QUrl)
\end{minted}
  \caption{Existing main tab API}
  \label{tabapi}
\end{figure}

\section{Other inspirations}
Various other existing projects served as an inspiration for qutebrowser's
extension API:

\begin{itemize}
  \item \fixme{Add simplicity details for pytest}
  \item The pytest project\footnote{\url{https://www.pytest.org/}} exposes a
    very simple and ``pythonic'' extension API. All that's needed to create a
    plugin is a specially named Python file which implements hook functions such
    as \py{def pytest_runtest_setup(item)}. However, giving trainings about
    pytest in companies, the author of this SA has noticed that some aspects of
    its plugin API are somewhat unintuitive. As an example, both the function
    name and the argument names (\verb|item|) need to match the definition.
    While some of its design decisions make sense, others should be solved
    differently in qutebrowser.
  \item The odoo project\footnote{\url{https://www.odoo.com/}} also follows the
    philosophy of having a small core which is extended with modules (some of
    which are shipped with the core). From some prior work experience, this SA's
    author has worked with odoo modules in the past -- unfortunately, the API
    for modules is complex and badly documented. Thus, odoo is mainly useful as
    a conceptual inspiration rather than an inspiration for API design.
\end{itemize}

% Bewertung (Evaluation)
\chapter{Evaluation}

% Kriterien (Wie wird bewertet?)
\section{Criteria}

\label{criteria}

There are various forces which affect design decisions for qutebrowser's
extension API:

\begin{description}
\item[Qt APIs] qutebrowser is built on top of the QtWebEngine/QtWebKit
rendering engines (which of the two to use is user-configurable). Sometimes,
while a clean API design for a given problem would exist, constraints imposed by
those libraries are a limiting factor and thus influence the API design.
The API to get the selected text from a web page is an ideal example: The most
straightforward API would be a \py{def selection() -> str} method. However,
JavaScript execution is needed to get the selection, which is only available
from Qt as a callback-based interface. Thus, the extension API will need to look
like \py{def selection(cb: Callable[[str], None])} \\ \py{-> None} -- in other words,
the \py{selection} method will take a callback function, which then gets called
with the selected text.

\item[Internal qutebrowser code] One of the main goals (as per the task
description) of this SA is moving code from qutebrowser's core into internal
``extensions'' shipped alongside qutebrowser. Components which use general-purpose
APIs (like the adblocker, which needs to intercept network requests) can
conveniently moved out of the core, and result in extension APIs which are also
usable for other purposes.

\item[Ideas for future extensions] While external extensions (contributed by the
qutebrowser community) are not the primary focus of this SA, a lot of use-cases
for extensions have been collected based on users' feature requests. Care should be
taken so the extension API can also satisfy those use cases in the future.

\item[Other extension APIs] There is a general consensus from browser vendors
around the WebExtension API. Unfortunately, that API is unsuitable for
qutebrowser, for reasons explained in chapter \ref{unsuitable}. It can still
serve as a source for inspiration.

\item[Python and Qt] While some higher-level architectural decisions are
independent from the programming language used to implement them, what is
commonly considered a ``good'' API certainly depends on the underlying
programming language and the idioms used therein. Since qutebrowser's extension
API is used from Python, it should aim to be ``Pythonic'' (i.e., adhering to
Python idioms\footnote{\url{https://blog.startifact.com/posts/older/what-is-pythonic.html}})
and also use features made available by Qt. As an example, a Pythonic API might
favor Python
decorators\footnote{\url{https://docs.python.org/3/glossary.html\#term-decorator}}
over inheritance to set up extension hooks; or a Qt API might prefer Qt's
signals/slots
facility\footnote{\url{https://doc.qt.io/qt-5/signalsandslots.html}} over a
callback-based API.
\end{description}

In addition to those external forces, it's helpful to have a set of self-imposed
design guidelines in mind when designing an API. For this project, it was
decided to adopt the \emph{``Characteristics of good APIs''} listed in
Jasmin~Blanchette's \emph{Little Manual of API Design}
\citep[p.~7ff]{api-design}:

\begin{description}
  \item[Easy to learn and memorize:] This also implies consistency and minimalism,
    as well as clear semantics, following the principle of least surprise.
  \item[Leads to readable code:] As the manual puts it: \emph{``Readable code can be
  concise or verbose. Either way, it is always at the right level of abstraction
  -- neither hiding important things nor forcing the programmer to specify
  irrelevant information''}.
  \item[Hard to misuse:] A well-designed API should assist its user in
    writing correct and clear code. 
  \item[Easy to extend:] New concepts will appear over time, and existing
    APIs will grow. While it's hard to anticipate the future, those concerns
    should be taken into account while designing an API.
  \item[Complete:] The manual claims \emph{``Ideally, an API should be
    complete and let users do everything they want.''}. However, this statement
    is later revised by adding \emph{``Completeness is also something that can appear
    over time, by incrementally adding functionality to existing APIs. However,
    it usually helps even in those cases to have a clear idea of the direction
    for future developments, so that each addition is a step in the right
    direction.''}
\end{description}

% Schlussfolgerungen, eigener Lösungsansatz
\section{Conclusion}
Designing an API always is a trade-off between various, sometimes conflicting,
forces. For qutebrowser's extension API, the focus should lie on being as
minimal and straightforward as possible, with the primary goal of moving
internal qutebrowser code to extensions.

While extensibility and completeness are valid concerns, they are less relevant
as the API is not open to third-party extensions yet.

\fixme{continue?}

% Umsetzungskonzept (des eigenen Lösungsansatzes)
\chapter{Concept}

% Grobe Beschreibung des eigenen Lösungskonzepts
\section{Summary}
\fixme{}

\section{Exposing existing APIs}
Many of the APIs which should be exposed to extensions already exist in
qutebrowser. However, exposing formerly private APIs carries certain risks:

\begin{itemize}
  \item Often, APIs do not undergo any review before they are made public
    \citep[p.18f]{api-design}, This can lead to mistakes which were not regarded
    as important (or not noticed at all) to be exposed publicly, without a way
    to remedy the mistakes (since that would be an incompatible change).
  \item Looking at the tab API explained in section \ref{tabapi}, some methods
    exist because there was a need in the core part for them -- but they should
    not be exposed to plugins, since they are only needed for very specialized
    reasons.
  \item When improving or refactoring APIs in the future, care must be taken
    because third-party extensions might be affected by the change. To avoid
    extension authors having to catch up with every upgrade of the core (and
    frustrating users due to breaking extensions), any future changes should be
    backwards-compatible, which greatly limits the room for future cleanups.
  \item Even for methods which seem useful for an extension API, their need
    should be carefully evaluated by looking at proposals for future extensions
    before blindly exposing them. This approach leads to a smaller (and thus
    simpler) API. It also increases the maintainability of the core, as parts
    which aren't exposed can be freely changed without needing to take care of
    extensions.
\end{itemize}

It must be noted that many of those issues are less relevant in the scope of
this SA, as the API will be open to third-party extensions at a later point.
However, care was taken to mitigate those issues where possible.

In order to catch possible issues with existing APIs planning to be exposed to
extensions, the existing APIs were reviewed by Raphael~Das~Gupta from the IFS
(Institute for Software).

It was considered to implement the object adapter pattern \citep[p.139]{gof} to
limit the methods exposed in the API to what is actually necessary:

\begin{figure}[h]
\centering
\begin{sequencediagram}
  \newinst{extension}{:Extension}
  \newinst{adapter}{:Adapter}
  \newinst{tab}{:Tab}
  \newinst{view}{:QWebEngineView}

  \begin{call}{extension}{title()}{adapter}{``Title''}
    \begin{call}{adapter}{title()}{tab}{``Title''}
      \begin{call}{tab}{title()}{view}{``Title''}
      \end{call}
    \end{call}
  \end{call}
\end{sequencediagram}
\caption{Sequence diagram for the extension API with adapter object}
\end{figure}

However, this would lead to a considerable amount of duplicated code: Big parts
of the tab API would need to be duplicated, just to pass calls through. Since
this solution provided an overhead which was considered too big compared to the
benefits, the following alternatives were considered:

\begin{itemize}
  \item The methods could be marked private via the common Python convention to
    start the name with an underscore (for example, \py{_shutdown()}).
    However, in the core part, those should \emph{not} be private, as they need to
    be used from outside the tab API.
  \item The methods could be lacking a Python docstring, so they are accessible,
    but excluded from the extension API documentation. However, auto-completion
    in development environments would still suggest those methods, which could
    lead to users thinking they are part of the exposed API. Additionally, this
    would make it impossible to document the affected methods for developers
    working on the core.
  \item Similar to existing members like \verb|.scroller| or \verb|.zoom|, a new
    \verb|.private_api| member could be introduced, which points to an object
    containing any methods not part of the public API.
\end{itemize}

The last solution was chosen since it clearly communicates (both in the
documentation and the name of the attribute) what part of the API is intended
for usage in the core only. This solution also still allows the core to access
those APIs, and the private API can still be documented properly.

% z.T. Wiederholung im Groben, z.T. Verweise auf Teil II-Kapitel
\section{Security}
\label{security}
As part of this SA, third-party extensions are out of scope; only code which was
part of qutebrowser's core is moved into extensions. Thus, it seems like there
are no special security considerations to be made. However, the architecture of
an extension API is fundamentally influenced by such considerations, and support
for third-party extensions will be added in the near future. Therefore, the
security philosophy of qutebrowser's extensions is analyzed in this section.

The security model of WebExtensions (see section \ref{webextensions}) assumes
that extensions are untrusted. Even with the limited WebExtensions API,
malicious extensions are a common issue
\citep{mozilla-signing,mozilla-trustworthy}. Browser vendors try to alleviate
this problem with automated and manual code review, extension signing, and
blacklisting of known-bad extensions. Additionally, the user explicitly needs to
allow extensions to run in incognito/private browsing mode, as the impact of a
privacy breach typically is considerably larger in that scenario.

The approach taken qutebrowser extensions is different: Extensions are treated
as trusted, so users are responsible for reviewing extensions before installing
them. This is for a variety of reasons:

\begin{itemize}
  \item Extensions for qutebrowser should be written in Python (like qutebrowser itself
    is), but safely executing untrusted Python code is commonly regarded to be
    impossible \citep{nedbat-eval, lwn-pysandbox}.
  \item The attack surface for a malicious actor trying to distribute a bad
    extension is much smaller, since qutebrowser caters to a relatively small
    niche group of users. Thus, malicious extensions are expected to be a seldom
    occurrence compared to more common browsers such as Google Chrome or Mozilla
    Firefox.
  \item Users of qutebrowser are typically power users, due to its
    keyboard-focused nature. With a browser aimed at casual users, it might be
    easy to trick them into installing an extension which is malicious. In
    contrast, users of qutebrowser can be expected to be much more diligent in ensuring that
    the extensions they're installing are not malicious.
  \item The volume of available extensions is much lower. Thus, it's conceivable
    that there's a whitelist of extensions which have been reviewed and approved
    by one of qutebrowser's core developers. A contributor wishing to distribute
    a new extension could then ask for it to be reviewed and included in that list.
  \item Due to the focus on power users, a user should always be able to
    install an extension manually, or write a custom one. Thus, mandatory
    extension signing or approval by a central body is undesirable, as it
    presents a trade-off between a user's freedom and security.
\end{itemize}

% % Design (Entwurf)
% \chapter{Design}
% 
% % Architektur
% \section{Architecture}
% 
% % Objektkatalog (Klassenkonzepte, Verantwortlichkeiten und Konsistenzbedingungen)
% \section{Objects}
% 
% % Package- und Klassendiagramme (konzeptionell)
% \section{Packages and Classes}
% 
% % Sequenzdiagramm, UI Design
% \section{Sequence Diagrams}

% Implementation (Entwicklung)
\chapter{Implementation and Test}

% Implementation: Erläuterungen wichtiger konkreter Klassen
\section{Important Classes}

% Automatische Testverfahren
\section{Automated Testing}

% Manuelle Testverfahren, etc.
\section{Manual Testing}


% Resultate, Bewerung und Ausblick
\chapter{Results}

% Zielerreichung
\section{Achievement of Objectives}


% Projektmonitoring (Ist-Beschreibung, so ist es passiert)
% \chapter{Project Monitoring}
% Soll-Ist-Zeit-Vergleich
\section{Allocated/Actual Time}
% Codestatistik (Zeilen: Kommentare, Klassen, Packages)
\section{Code Statistics}

\section{Software Documentation}
% Maybe separate (Sphinx)


% Ausblick: Weiterentwicklung (nur wichtigste Punkte)
\section{Future Work}

% From project management part:
% % Resultate und Weiterentwicklung
% \chapter{Results and Future Work}
% 
% % Resultate (ev. nach oben in Teil I Kap. 5 eingleidern)
% \section{Results}
% 
% % Möglichkeiten der Weiterentwicklung
% \section{Possible Future Work}
% 
% % Vorgehen (welche Mögl. würde man nun wie weiterentwickeln?)
% \section{Future Approach}



% Persönliche Berichte
\section{Personal Review}

% Dank
\section{Acknowledgements}
Working on an open-source project with an idea contributed by a student, as well
as doing an SA as a single person, is rather untypical. I'm very grateful that
Prof.~Stefan~Keller was open to mentor this project as an advisor despite the
unusual conditions. His support and insights in our regular meetings were
invaluable.

Thanks to the qutebrowser community for making qutebrowser into far more than
just a personal pet project of mine. Without this community, I doubt I would
still be working on it after five years -- when I started, I never imagined that
it would get that far.

I'm thankful to all qutebrowser contributors for their patience and
understanding when I couldn't attend to their contributions in a timely manner
while working on this project. I'd especially like to thank Fritz~Reichwald for
his contributions towards switching to the Sphinx documentation generator, and
our careful coordination in order to not interfere with my own work on this
project.

Thanks to AnneMarie~O'Neill for her careful English reviews and constructive
feedback on possible improvements. Her suggestions were always very welcome and
accurate.

Last but not least, thanks to Méline~Sieber for her constant encouragement
throughout the semester, and for always helping me out of the maze when I got
stuck somewhere.



\begin{appendices}
\chapter{Glossary and Abbreviations}
\begin{description}
  \item[API]{Application Programming Interface, i.e., in
      case of an extension API, the functions and classes (names, arguments,
      etc.) an extension can implement.}
  \item[add-on]{A synonym for \emph{extension}.}
  \item[backend]{The software library doing the ``heavy lifting'' in
      qutebrowser, such as doing network requests or drawing website content.}
  \item[CI]{Continuous integration, i.e., running automated tests or other
      checks with every change.}
  \item[DOM]{Document Object Model, the \emph{API} to access a HTML document as
      a tree structure.}
  \item[extension]{Code using an \emph{API} in order to extend the functionality
      of an existing project.}
  \item[GUI]{Graphical User Interface}
  \item[HSR]{The Hochschule für Technik (University of Applied Sciences) in
      Rapperswil, Switzerland.}
  \item[IFS]{The Institute for Software at \emph{HSR}.}
  \item[plugin]{In most contexts, the same as an \emph{extension}. Note that
      qutebrowser initially used \emph{plugin API} to refer to its extension
      API. However, this should be avoided, as ``plugin'' is too ambiguous in
      the context of web browsers: A plugin usually refers to software using the
      deprecated NPAPI (Netscape Plugin API) or PPAPI (Pepper Plugin API)
      technologies, such as Adobe Flash.}
  \item[Python]{The programming language used to write qutebrowser.}
  \item[PyQt]{A software library which allows to use \emph{Qt} from \emph{Python}.}
  \item[Qt]{The \emph{GUI} library used by qutebrowser}
  \item[QtWebEngine]{The \emph{backend} used by default in qutebrowser, based on
      the Chromium project (like the Chrome web browser).}
  \item[QtWebKit]{One of two possible \emph{backends} qutebrowser can use.
      QtWebKit is the older backend, which isn't used by default anymore, but is
      still supported.}
  \item[SA]{Studienarbeit (Student research project)}
  \item[W3C]{World Wide Web Consortium, the standards body for web-related
      technologies such as HTML.}
\end{description}

\nocite{yapproach}
\renewcommand{\bibname}{\chapter{Literature and Sources}}
\bibliographystyle{IEEEtranN}
\bibliography{bibliography}
\end{appendices}

\end{document}

\documentclass[a4paper,parskip=full]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage{cmbright}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{minted}

\newcommand{\py}[1]{\mintinline{python}{#1}}
\newcommand{\fixme}[1]{\textbf{FIXME} \emph{#1}}

\hyphenation{Web-Extension}
\hyphenation{Web-Extensions}

\begin{document}

%\title{qutebrowser made extendible \\ FIXME}
%\author{Florian Bruhin \\ \url{florian@qutebrowser.org}}
%\date{\today}
%\maketitle

\begin{titlepage}

\begin{flushleft}

% Upper part of the page
\noindent\begin{minipage}[t]{0.49\textwidth}
	\begin{flushleft}
		\vspace{3pt} %needed else aligned to bottom
		\includegraphics[height=0.12\textheight]{img/hsr.eps}
	\end{flushleft}
\end{minipage}
\hfill
\begin{minipage}[t]{0.49\textwidth}
	\begin{flushright}
		\vspace{0pt} %needed else aligned to bottom
		\includegraphics[height=0.15\textheight]{img/qutebrowser.png}
	\end{flushright}
\end{minipage}
\\[4cm]

{\huge \bfseries qutebrowser made extendible}\\[0.5cm]
%{\large \bfseries Student Research Project (Studienarbeit)}\\[2cm]
{\large \bfseries Term Project (Studienarbeit) \\[0.2cm] Autumn Term 2018/2019}\\[2cm]

Department of Computer Science\\
University of Applied Sciences Rapperswil (HSR)\\
\url{www.hsr.ch}\\[1cm]

% Author and advisor
Author: Florian Bruhin\\[0.3cm]
Advisor: Prof.~Stefan Keller, HSR\\[0.3cm]
External Co-Examiner: Claude Eisenhut, Eisenhut Informatik AG

% Bottom of the page
\vfill
Date: {\today}

\end{flushleft}

\end{titlepage}



\chapter*{Abstract}

\chapter*{Management Summary}


\tableofcontents
\listoffigures
\listoftables


% Aufgabenstellung
\chapter*{Task Definition}  

% Technischer Bericht
\part{Technical Report}

% Einführung
\chapter{Introduction}

\section{Background}

\fixme{main focus: What's qutebrowser about? When/technology should be in the
  second paragraph. Maybe define web browser. Also define Python/PyQt. List
alternatives.}

The qutebrowser project exists since December 2013. It is a keyboard-focused
web browser with a minimal GUI, based on Python and PyQt5.

A plugin API for users to write their own extensions to qutebrowser is a
long-standing feature
request\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/30}},
which has often been requested by its users.

It is difficult to estimate qutebrowser's user count, but it is likely used by a
couple thousand users, so a plugin API is also vital in order to be able to move
less popular features out of the core part of qutebrowser.

% Problemstellung, Vision
\section{Vision}

\fixme{further define power users}

Many qutebrowser users are power-users and, as such, have very specific (and
sometimes unique) feature requests and workflows. It should be made possible for
those users to extend qutebrowser with custom plugins in an easy way, in order
to keep qutebrowser's core small.

Since qutebrowser already has a thriving community, this change also intends to
decentralize development efforts, as it enables power-users and
developers to maintain their plugins independently from the core development.

% Ziele und Unterziele
\section{Goals}

Initially, qutebrowser was developed without knowledge of proper software
engineering practices, which resulted in some maintainability issues. While many
of those issues have been fixed since, some still remain. Those
refactorings affect the API exposed to plugins, and therefore should be taken
care of before attempting to design a plugin API.

The full list of relevant refactorings is tracked as a Kanban
board\footnote{\url{https://github.com/qutebrowser/qutebrowser/projects/3}} in
qutebrowser's GitHub repository. The biggest planned changes are the following:

\begin{itemize}
  \item \url{https://github.com/qutebrowser/qutebrowser/issues/1456}: \\ Parts of qutebrowser already use Python type
    annotations\footnote{\url{https://www.python.org/dev/peps/pep-0484/}}, but
    only if contributors decide to use them. In addition to that, no type
    checker such as mypy\footnote{\url{http://mypy-lang.org/}} is currently run
    as part of qutebrowser's continuous integration (CI) pipeline, thus allowing
    regressions to occur. As part of this project, a type checker should be
    introduced into the CI infrastructure, and any code exposed via the plugin
    API should be annotated with proper type annotations.
  \item \url{https://github.com/qutebrowser/qutebrowser/issues/345}: \\
    To generate HTML documentation, qutebrowser currently uses
    asciidoc\footnote{\url{http://asciidoc.org/}} which is unsuitable for API
    documentation and ceased maintenance. An external contributor (see page
    \pageref{fiete}) is currently working on migrating to the
    Sphinx\footnote{\url{http://www.sphinx-doc.org/}} toolchain, and should be
    supported with his work throughout the SA.
  \item \url{https://github.com/qutebrowser/qutebrowser/issues/640}: \\
    Global objects are registered in a object registry based on a name as
    string (``stringly-typed''\footnote{\url{http://wiki.c2.com/?StringlyTyped}}).
    This historically caused various object-lifetime related issues, and also
breaks tooling such as the mypy type checker. All code using the object registry
should be refactored to use better alternatives such as constructor arguments
(dependency injection).
\end{itemize}

% Rahmenbedingungen, Umfeld, Definitionen, Abgrenzungen
\section{Context}

The software and version constraints are mostly given by the existing project:

\begin{itemize}
  \item Python\footnote{\url{https://www.python.org/}} 3 (3.5 or newer)
  \item Qt\footnote{\url{https://www.qt.io/}} 5 (5.7 or newer), used via PyQt5\footnote{\url{https://www.riverbankcomputing.com/software/pyqt/intro}}
  \item pytest\footnote{\url{https://pytest.org/}} as test framework
  \item Various code quality tools: pylint\footnote{\url{https://pylint.org/}},
    flake8\footnote{\url{http://flake8.pycqa.org/}} and others.
\end{itemize}

As qutebrowser is a pre-existing project with a vibrant community, external
contributions are expected to continue (despite an
announcement\footnote{\url{https://lists.schokokeks.org/pipermail/qutebrowser-announce/2018-October/000053.html}}
asking people to hold back bigger contributions). This can be challenging,
as it results in refactorings being carried out against a moving target. Because
of the nature of open-source contributions,
% http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/
% https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/
it is hard to foresee or control which areas external contributors are changing.
At the beginning of the SA, some time was allocated for merging external
contributions (pull requests) which were already open. For the rest of the SA,
such contributions will be dealt with on a best effort basis, with the main
focus being this documentation and the work required for the plugin API.

% Vorgehen, Aufbau der Arbeit
\section{Methods and Structure}



% "Stand der Technik" (Was gibt es schon?)
\chapter{Existing APIs}
\label{unsuitable}

\fixme{}: Introductory text here?

\section{Firefox XUL plugins}

Older versions of the Firefox web browser used to have a very powerful plugin
API, based on its XUL (XML User Interface Language) technology. However, this
approach came with various issues and was thus recently abandoned, while
adopting the WebExtensions standard.

The apparent philosophy behind ``legacy'' Firefox addons was to allow maximum
customizability from extensions -- however, this came with various drawbacks
which ultimately lead to Mozilla abandoning that approach.

The motivations to deprecate and subsequently remove the legacy addon API listed
in Mozilla's blog post \citep{mozilla-webext} were as follows:

\begin{itemize}
  \item Chrome and Opera (and nowadays also Microsoft Edge) already supported
    the WebExtension API, so a switch to the WebExtension API would drastically
    reduce the effort required for developers when implementing extensions with
    cross-browser compatibility: \emph{``We would like add-on development to be more
    like Web development: the same code should run in multiple browsers according to
    behavior set by standards, with comprehensive documentation available from
    multiple vendors.''}
  \item Firefox' Electrolysis (e10s)
    project\footnote{\url{https://wiki.mozilla.org/Electrolysis}} was a big
    change in its codebase, with the goal of separating tabs into separate
    processes, for security and performance reasons. Many legacy addons were not
    compatible with the changes necessary for Electrolysis. This forced either
    the add-on developer to make (sometimes intricate) changes to their code; or
    the user's Firefox instance to run in a special fallback mode: \emph{``Add-ons
    that haven’t been upgraded to work with Electrolysis will run in a special
    compatibility environment that resembles single-process Firefox as much as
    possible. [...] However, [the fallback is] much slower than the equivalent DOM
    operations in single-process Firefox, and can affect the user experience
    negatively. Also, some accesses aren’t supported by the compatibility layer and
    will throw exceptions.''}
  \item Since Firefox is a quite popular product, malicious Firefox addons
    started to become an attractive attack vector for bad actors. With legacy
    addons, addon code is able to run arbitrary code and freely modify Firefox
    internals on the user's machine, which turns untrusted addons into a
    security liability \citep{mozilla-signing}.
  \item Legacy addons hindered Firefox development in general, since its
    powerful addon API introduced a tight coupling between Firefox' internal
    code, and the code in third-party addons: \emph{``A permissive add-on model
    means that we have limited flexibility in changing the foundations of Firefox.
    [...] Without a fundamental shift to the way Firefox add-ons work, we will
    be unable to use new technologies like Electrolysis, Servo\footnote{An
      experimental new rendering engine by Mozilla, implemented in the Rust
      programming language. Parts of Servo (such as its CSS renderer) have since
    been merged into Firefox.} or browser.html\footnote{A Mozilla research
    project which implements a browser completely in HTML, now retired.}
    as part of Firefox. The tight coupling between the browser and its add-ons
    also creates shorter-term problems for Firefox development. It’s not uncommon
    for Firefox development to be delayed because of broken add-ons.''}
\end{itemize}

While qutebrowser should learn from the mistakes made in Firefox' legacy API,
there is a fundamental difference in the two approaches: qutebrowser plugins
should be written in the Python language (like qutebrowser itself is), but
safely executing untrusted Python code proved to be impossible
\citep{nedbat-eval, lwn-pysandbox}. \fixme{separate security chapter?}

A more thorough analysis of the XUL API design proved to be difficult. While
archived API documentation is still
available\footnote{\url{https://developer.mozilla.org/en-US/docs/Archive/Add-ons}},
bad documentation was one of the criticisms of XUL addons
\citep{mozilla-webext}. Since the API is not in active use anymore, and ties
into Firefox' core code deeply, no further analysis was performed.

The key takeaway for qutebrowser is that it should have a minimal and clearly
outlined plugin API, rather than naively exposing its internal Python code to
plugins.

\section{WebExtensions}

Currently, there are ongoing efforts towards an API for browser
extensions called \emph{WebExtensions}, which is shared between different
browsers. Mostly compatible subsets of it are supported by Chrome, Opera,
Firefox and Edge. Efforts are currently underway to standardize the API
as a W3C specification \citep{w3c-webext}.

If qutebrowser would support the WebExtension API, it would follow a common
standard, and enable running thousands of existing Chromium extensions with
little to no adjustment to their code.

Unfortunately, WebExtensions are unsuitable for qutebrowser, for various
reasons:

\begin{itemize}
  \item \fixme{todo}
\end{itemize}

\fixme{continue here}

but it can
be used as a source of inspiration. However, the WebExtension API is closely
tied to the JavaScript language, so architecture decisions taken there will not
necessarily be applicable to qutebrowser's Python plugin API.

Unfortunately, this standard is unsuitable for qutebrowser, as further explained
in this chapter.



% Bestehende Lösungsansätze und Normen
%\section{Existing APIs}

% Kurzbeschreibung und Charakterisierung
% \section{Summary and Characerization}

% Defizite (Hinweise auf Weiterentwicklungs-, bzw. Verbesserungspotential)
%\section{Problems with existing solutions}  

% Bewertung (Evaluation)
\chapter{Evaluation}

% Kriterien (Wie wird bewertet?)
\section{Criteria}

There are various forces which affect design decisions for qutebrowser's plugin
API:

\paragraph{Qt APIs} qutebrowser is built on top of the QtWebEngine/QtWebKit
rendering engines (which of the two to use is user-configurable). To some
degree, the APIs exposed by those libraries also dictates how the API
qutebrowser can expose to plugins can look. The API to get the selected text
from a web page is an ideal example: The most straightforward API would be a
\py{def selection() -> str} method. However, JavaScript execution is needed to get
the selection, which is only available from Qt as a callback-based interface.
Thus, the plugin API will need to look like
\py{def selection(cb: Callable[[str], None]) -> None} --
in other words, the \py{selection} method will take a
callback function, which then gets called with the selected text.

\paragraph{Internal qutebrowser code} One of the main goals (as per the task
description) of this SA is moving code from qutebrowser's core into internal
``plugins'' shipped alongside qutebrowser. Components which use general-purpose
APIs (like the adblocker, which needs to intercept network requests) can
conveniently moved out of the core, and result in plugin APIs which are also
usable for other purposes.

\paragraph{Ideas for future plugins} While external plugins (contributed by the
qutebrowser community) are not the primary focus of this SA, a lot of use-cases
for plugins have been collected based on users' feature requests. Care should be
taken so the plugin API can also satisfy those use cases in the future.

\paragraph{Other plugin APIs} There is a general consensus from browser vendors
around the WebExtension plugin API. Unfortunately, that API is unsuitable for
qutebrowser, for reasons explained in chapter \ref{unsuitable}. It can still
serve as a source for inspiration.

\paragraph{Python and Qt} While some higher-level architectural decisions are
independent from the programming language used to implement them, what is
commonly considered a ``good'' API certainly depends on the underlying
programming language and the idioms used therein. Since qutebrowser's plugin API
is used from Python, it should aim to be ``Pythonic'' (i.e., adhering to Python
idioms\footnote{\url{https://blog.startifact.com/posts/older/what-is-pythonic.html}})
and also use features made available by Qt. As an example, a Pythonic API might
favor Python
decorators\footnote{\url{https://docs.python.org/3/glossary.html\#term-decorator}}
over inheritance to set up plugin hooks; or a Qt API might prefer Qt's
signals/slots
facility\footnote{\url{https://doc.qt.io/qt-5/signalsandslots.html}} over a
callback-based API.


% Schlussfolgerungen, eigener Lösungsansatz
\section{Conclusion}


% Umsetzungskonzept (des eigenen Lösungsansatzes)
\chapter{Concept}

% Grobe Beschreibung des eigenen Lösungskonzepts
\section{Summary}

% z.T. Wiederholung im Groben, z.T. Verweise auf Teil II-Kapitel
\section{...}


% Resultate, Bewerung und Ausblick
\chapter{Results}

% Zielerreichung
\section{Achievement of Objectives}

% Ausblick: Weiterentwicklung (nur wichtigste Punkte)
\section{Future Work}

% Persönliche Berichte
\section{Personal Review}

% Dank
\section{Thanks}



% Teil II SW-Projektdokumentation ("klassisches" RUP 2/HSR)  
\part{Project Documentation}


% Vision (ev. auf Kapitel 1.1 verweisen)
\chapter{Vision}


% Anforderungsspezifikation
\chapter{Requirements Specification}

% Anforderung an die Arbeit
\section{Requirements of the Project}

% Use Cases (Success Scenario / Success Diagram)
\section{Use Cases}

% System-Sequenzdiagramme
\section{System Sequence Diagrams}

% Weitere Funktionen, die nicht erfasst wurden
\section{Further Functionality}

% Nicht-funktionale Anforderungen (Rahmbenbedingungen, evtl. Verweis auf 1.3)
\section{Non-functional Requirements}

% Detailspezifikation
\section{Detailed Specification}


% Analyse (Business Model)
\chapter{Analysis}

% Domain Modell, Klassendiagramme (konzeptionell)
\section{Domain Model}

% Objektkatalog (Beschreibung der Konzepte, bzw. Entitätsmengen)
\section{Objects}


% Design (Entwurf)
\chapter{Design}

% Architektur
\section{Architecture}

% Objektkatalog (Klassenkonzepte, Verantwortlichkeiten und Konsistenzbedingungen)
\section{Objects}

% Package- und Klassendiagramme (konzeptionell)
\section{Packages and Classes}

% Sequenzdiagramm, UI Design
\section{Sequence Diagrams}


% Implementation (Entwicklung)
\chapter{Implementation and Test}

% Implementation: Erläuterungen wichtiger konkreter Klassen
\section{Important Classes}

% Automatische Testverfahren
\section{Automated Testing}

% Manuelle Testverfahren, etc.
\section{Manual Testing}


% Resultate und Weiterentwicklung
\chapter{Results and Future Work}

% Resultate (ev. nach oben in Teil I Kap. 5 eingleidern)
\section{Results}

% Möglichkeiten der Weiterentwicklung
\section{Possible Future Work}

% Vorgehen (welche Mögl. würde man nun wie weiterentwickeln?)
\section{Future Approach}


% Projektmanagement (Planung, Soll)
\chapter{Project Management}

% Prototypen, Releases, Meilensteine
\section{Prototypes, Releases, Milestone}

% Team, Rollen und Verantwortlichkeiten
\section{Team and Roles}
\emph{Florian Bruhin} is both the primary maintainer of qutebrowser and the
author of this student research project. He has been working on qutebrowser since
December 2013 and started studying Computer Science at HSR in 2016.

Professor \emph{Stefan Keller}, institute partner at the Institute for Software
(IFS) at HSR is the advisor for this project.

The qutebrowser community is not directly involved in this research project, but
is the primary audience of the resulting work. It has also contributed many
ideas and use cases for future
plugins\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/30}}.

\label{fiete}
\emph{Fritz Reichwald} (fiete201\footnote{\url{https://github.com/fiete201}})
is a long-time qutebrowser user who is working on migrating qutebrowser's
documentation system from asciidoc\footnote{\url{http://asciidoc.org/}} (which
is deprecated) to the Sphinx\footnote{\url{http://www.sphinx-doc.org/}}
documentation generator. This change was
planned\footnote{\url{https://github.com/qutebrowser/qutebrowser/issues/345}}
since December 2014, so his help with tackling this is very much appreciated.
This project will benefit from his work, as Sphinx, unlike asciidoc, is a
very good fit for documenting APIs. His work is clearly marked as such in this
documentation.

% Aufwandschätzung, Zeitplan, Projektplan
\section{Project Schedule}
% Risiken
\section{Risks}
% Prozessmodel
\section{Process Model}


% Projektmonitoring (Ist-Beschreibung, so ist es passiert)
\chapter{Project Monitoring}
% Soll-Ist-Zeit-Vergleich
\section{Allocated/Actual Time}
% Codestatistik (Zeilen: Kommentare, Klassen, Packages)
\section{Code Statistics}


\chapter{Software Documentation}
% Maybe separate (Sphinx)



\part{Appendices}


\chapter{Glossary and Abbreviations}

Test \citep{yapproach}

\renewcommand{\bibname}{\chapter{Literature and Sources}}
\bibliographystyle{IEEEtranN}
\bibliography{bibliography}

\end{document}
